#!/usr/bin/env python3
"""Quick Gantt-style visualisation for interpretability traces.

This script consumes the CSV artifacts produced by
``analysis/interpretability_case_study.py`` (specifically ``trace_entries.csv``)
and renders a simple timeline illustrating task decisions over the scheduling
horizon. Each bar encodes the shaped reward magnitude via colour, making it
straightforward to spot risky vs. beneficial assignments.
"""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import Optional

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

sns.set_theme(style="whitegrid")


def load_entries(csv_path: Path) -> pd.DataFrame:
    df = pd.read_csv(csv_path)
    required = {"task_name", "decision_host", "agent_eft", "shaped_reward"}
    missing = required - set(df.columns)
    if missing:
        raise ValueError(f"CSV missing required columns: {sorted(missing)}")
    return df


def filter_entries(
    df: pd.DataFrame,
    workflow: Optional[str],
    episode: Optional[int],
) -> pd.DataFrame:
    subset = df.copy()
    if workflow:
        subset = subset[subset["workflow_file"] == workflow]
    if episode is not None:
        subset = subset[subset["episode"] == episode]
    return subset.sort_values("agent_eft").reset_index(drop=True)


def plot_gantt(
    df: pd.DataFrame,
    output_path: Path,
    *,
    title: str,
    time_scale: float = 1.0,
) -> None:
    if df.empty:
        raise ValueError("No entries available after filtering; aborting plot.")
    df = df.copy()
    df["reward"] = df["shaped_reward"].astype(float)
    df["agent_eft"] = df["agent_eft"].astype(float)

    # Determine bar width heuristically from spacing between decisions.
    diffs = df["agent_eft"].diff().abs().dropna()
    if not diffs.empty and diffs.max() > 0:
        inferred_width = max(diffs.median(), diffs.mean() * 0.5)
    else:
        inferred_width = 0.0
    bar_width = max(time_scale, inferred_width, 1e-3)
    df["start_time"] = df["agent_eft"] - bar_width * 0.5
    df["end_time"] = df["agent_eft"] + bar_width * 0.5

    fig_height = min(18, max(5, len(df) * 0.35))
    fig, ax = plt.subplots(figsize=(12, fig_height))
    cmap = sns.diverging_palette(220, 10, as_cmap=True)
    reward_min, reward_max = df["reward"].min(), df["reward"].max()
    if abs(reward_min) > 0 and abs(reward_max) > 0:
        limit = max(abs(reward_min), abs(reward_max))
        norm = plt.Normalize(vmin=-limit, vmax=limit)
    else:
        norm = plt.Normalize(vmin=reward_min, vmax=reward_max if reward_max != reward_min else reward_min + 1e-3)

    y_positions = range(len(df))
    for y, (_, row) in zip(y_positions, df.iterrows()):
        ax.barh(
            y=y,
            width=row["end_time"] - row["start_time"],
            left=row["start_time"],
            color=cmap(norm(row["reward"])),
            edgecolor="black",
            linewidth=0.6,
            alpha=0.9,
        )
        ax.text(
            row["start_time"] + (row["end_time"] - row["start_time"]) * 0.02,
            y,
            f"{row['task_name']}",
            va="center",
            ha="left",
            fontsize=8,
            color="black",
        )
        ax.text(
            row["end_time"],
            y,
            f"{row['decision_host']}\nΔφ={row['potential_delta']:.3f}\nr={row['reward']:.3f}",
            va="center",
            ha="left",
            fontsize=7,
            color="dimgray",
        )

    ax.set_yticks(list(y_positions))
    ax.set_yticklabels([f"#{idx+1}" for idx in y_positions])
    ax.invert_yaxis()
    ax.set_xlabel("Estimated finish time (sim units)")
    ax.set_title(title)
    ax.grid(axis="x", linestyle="--", alpha=0.3)
    ax.grid(axis="y", linestyle=":", alpha=0.2)
    for spine in ["top", "right"]:
        ax.spines[spine].set_visible(False)

    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
    sm.set_array([])
    cbar = fig.colorbar(sm, ax=ax, pad=0.02)
    cbar.set_label("Shaped reward")
    fig.tight_layout()
    output_path.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output_path, dpi=200)
    plt.close(fig)
    print(f"Saved Gantt plot -> {output_path}")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Render a Gantt-style trace visualisation from trace_entries.csv.")
    parser.add_argument("entries_csv", type=Path, help="Path to trace_entries.csv generated by interpretability_case_study.py")
    parser.add_argument("--workflow", help="Optional workflow file filter.")
    parser.add_argument("--episode", type=int, help="Optional episode filter.")
    parser.add_argument("--output", type=Path, required=True, help="Output image path (PNG).")
    parser.add_argument("--time-scale", type=float, default=1.0, help="Width assigned to each bar (sim units).")
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    entries_csv = args.entries_csv.expanduser().resolve()
    if not entries_csv.exists():
        raise FileNotFoundError(entries_csv)
    df = load_entries(entries_csv)
    df = filter_entries(df, args.workflow, args.episode)
    output_path = args.output.expanduser().resolve()
    title = "Trace Gantt"
    if args.workflow:
        title += f" | {args.workflow}"
    if args.episode is not None:
        title += f" | Episode {args.episode}"
    plot_gantt(df, output_path, title=title, time_scale=max(args.time_scale, 1e-6))


if __name__ == "__main__":  # pragma: no cover
    main()
