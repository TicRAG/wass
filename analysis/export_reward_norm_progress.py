#!/usr/bin/env python3
"""Utility to append reward-normalization metrics for downstream notebooks.

The script ingests the aggregated summary generated by ``analysis/plot_results.py``
and records a per-family snapshot with a timestamp. Downstream notebooks can then
load ``results/training_runs/reward_norm_progress.csv`` to trace trends (e.g.
seismology rag_mean drifting negative) across training runs.
"""

from __future__ import annotations

import argparse
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable

import pandas as pd

DEFAULT_SUMMARY = Path("results/training_runs/reward_norm_summary.csv")
DEFAULT_OUTPUT = Path("results/training_runs/reward_norm_progress.csv")
DEFAULT_FAMILY = "seismology"


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Export reward-normalization snapshot for notebooks.")
    parser.add_argument(
        "--summary",
        type=Path,
        default=DEFAULT_SUMMARY,
        help="Path to reward_norm_summary.csv produced by analysis/plot_results.py.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="CSV file that will accumulate per-run snapshots for notebooks.",
    )
    parser.add_argument(
        "--family",
        default=DEFAULT_FAMILY,
        help="Workflow family to track (default: seismology).",
    )
    parser.add_argument(
        "--warn-threshold",
        type=float,
        default=-0.05,
        help="Emit a warning if rag_mean drops below this value (default: -0.05).",
    )
    return parser.parse_args()


def load_summary(summary_path: Path) -> pd.DataFrame:
    if not summary_path.exists():
        raise FileNotFoundError(f"Summary CSV not found: {summary_path}")
    df = pd.read_csv(summary_path)
    expected_cols = {
        "scope",
        "family",
        "rag_mean",
        "rag_std",
        "rag_positive_frac",
        "rag_negative_frac",
        "reward_mean",
        "reward_std",
        "reward_positive_frac",
        "reward_negative_frac",
        "final_reward_component",
    }
    missing = expected_cols - set(df.columns)
    if missing:
        raise ValueError(f"Summary CSV missing columns: {sorted(missing)}")
    return df


def extract_family_row(df: pd.DataFrame, family: str) -> pd.Series:
    family_lower = family.lower()
    candidates = df[(df["scope"] == "by_family") & (df["family"].str.lower() == family_lower)]
    if candidates.empty:
        raise ValueError(f"No summary row found for family='{family}'.")
    return candidates.iloc[0]


def append_snapshot(output_path: Path, snapshot: pd.DataFrame) -> None:
    if output_path.exists():
        existing = pd.read_csv(output_path)
        combined = pd.concat([existing, snapshot], ignore_index=True)
        combined = combined.drop_duplicates(subset=["summary_mtime", "family"], keep="last")
    else:
        combined = snapshot
    output_path.parent.mkdir(parents=True, exist_ok=True)
    combined.to_csv(output_path, index=False)


def main() -> None:
    args = parse_args()
    df = load_summary(args.summary)
    family_row = extract_family_row(df, args.family)
    summary_mtime = datetime.fromtimestamp(args.summary.stat().st_mtime, tz=timezone.utc)
    snapshot = pd.DataFrame(
        {
            "timestamp": [datetime.now(tz=timezone.utc).isoformat()],
            "summary_mtime": [summary_mtime.isoformat()],
            "family": [family_row["family"]],
            "rag_mean": [family_row["rag_mean"]],
            "rag_std": [family_row["rag_std"]],
            "rag_positive_frac": [family_row["rag_positive_frac"]],
            "rag_negative_frac": [family_row["rag_negative_frac"]],
            "reward_mean": [family_row["reward_mean"]],
            "reward_std": [family_row["reward_std"]],
            "reward_positive_frac": [family_row["reward_positive_frac"]],
            "reward_negative_frac": [family_row["reward_negative_frac"]],
            "final_reward_component": [family_row["final_reward_component"]],
            "rag_warn_threshold": [args.warn_threshold],
        }
    )
    append_snapshot(args.output, snapshot)
    rag_mean = float(family_row["rag_mean"])
    if rag_mean < args.warn_threshold:
        print(
            f"WARN {family_row['family']} rag_mean={rag_mean:.3f} is below threshold {args.warn_threshold:.3f}; consider retraining."
        )
    else:
        print(
            f"OK   {family_row['family']} rag_mean={rag_mean:.3f} above threshold {args.warn_threshold:.3f}."
        )
    print(f"Snapshot appended to {args.output}")


if __name__ == "__main__":
    main()
